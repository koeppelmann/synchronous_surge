<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Synchronous Rollup Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    body {
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 2px solid #4a90d9;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
    .card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card h2 {
      margin-top: 0;
      color: #4a90d9;
      font-size: 1.2em;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .card h2 .toggle-btn {
      font-size: 12px;
      padding: 4px 8px;
      background: #e9ecef;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: #555;
    }
    input, select, textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4a90d9;
    }
    textarea {
      min-height: 80px;
      font-family: monospace;
    }
    button {
      background: #4a90d9;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin-right: 10px;
    }
    button:hover {
      background: #357abd;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    button.secondary {
      background: #6c757d;
    }
    button.secondary:hover {
      background: #5a6268;
    }
    button.small {
      padding: 6px 12px;
      font-size: 13px;
    }
    .row {
      display: flex;
      gap: 15px;
    }
    .row > * {
      flex: 1;
    }
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .checkbox-group input {
      width: auto;
    }
    .status {
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
    }
    .status.info {
      background: #e7f3ff;
      color: #0066cc;
    }
    .status.success {
      background: #e6f7e6;
      color: #008000;
    }
    .status.error {
      background: #ffe6e6;
      color: #cc0000;
    }
    .hidden { display: none; }

    /* Status Dashboard Styles */
    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .chain-status {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      border-left: 4px solid #4a90d9;
    }
    .chain-status.l2 {
      border-left-color: #28a745;
    }
    .chain-status h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #333;
    }
    .status-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid #e9ecef;
      font-size: 13px;
    }
    .status-row:last-child {
      border-bottom: none;
    }
    .status-label {
      color: #666;
    }
    .status-value {
      font-family: monospace;
      color: #333;
      font-weight: 500;
    }
    .status-value.hash {
      font-size: 11px;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .copyable {
      cursor: pointer;
      position: relative;
    }
    .copyable:hover {
      background: #e9ecef;
      border-radius: 3px;
    }
    .copyable:active {
      background: #dee2e6;
    }
    .copy-tooltip {
      position: absolute;
      background: #333;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .copy-tooltip.show {
      opacity: 1;
    }
    .status-value.match {
      color: #28a745;
    }
    .status-value.mismatch {
      color: #dc3545;
    }

    /* State History */
    .state-block {
      background: white;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 8px;
      border-left: 4px solid #4a90d9;
      font-size: 12px;
    }
    .state-block.genesis {
      border-left-color: #28a745;
    }
    .state-block.l2-block {
      border-left-color: #4a90d9;
    }
    .state-block.incoming-call {
      border-left-color: #fd7e14;
    }
    .state-block .event-type {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 600;
      margin-left: 8px;
    }
    .state-block .event-type.l2-tx {
      background: #e7f3ff;
      color: #4a90d9;
    }
    .state-block .event-type.l1-to-l2 {
      background: #fff3e6;
      color: #fd7e14;
    }
    .state-block .block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .state-block .block-number {
      font-weight: 600;
      color: #333;
    }
    .state-block .block-time {
      font-size: 11px;
      color: #999;
    }
    .state-block .state-transition {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: monospace;
      font-size: 11px;
    }
    .state-block .hash {
      background: #f8f9fa;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .state-block .hash:hover {
      background: #e9ecef;
    }
    .state-block .arrow {
      color: #666;
      font-size: 14px;
    }
    .state-block .tx-info {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e9ecef;
      font-size: 11px;
      color: #666;
    }
    .state-block .tx-info code {
      background: #f8f9fa;
      padding: 2px 4px;
      border-radius: 3px;
    }

    /* Balances Table */
    .balances-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 10px;
    }
    .balances-table th, .balances-table td {
      padding: 8px 12px;
      text-align: left;
      border-bottom: 1px solid #e9ecef;
    }
    .balances-table th {
      background: #f8f9fa;
      font-weight: 600;
      color: #555;
    }
    .balances-table td {
      font-family: monospace;
    }
    .balances-table td.address {
      font-size: 11px;
      max-width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }
    .balances-table td.address:hover {
      background: #e9ecef;
    }
    .balances-table tr:hover {
      background: #f8f9fa;
    }

    /* Collapsible sections */
    .collapsible-content {
      transition: max-height 0.3s ease-out;
      overflow: hidden;
    }
    .collapsible-content.collapsed {
      max-height: 0;
      padding: 0;
    }

    /* Transaction form styles */
    .proxy-info {
      background: #fff3cd;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      font-size: 13px;
    }
    .proxy-info code {
      background: #f8f9fa;
      padding: 2px 6px;
      border-radius: 3px;
    }
    #logs {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .log-entry {
      margin-bottom: 5px;
    }
    .log-entry.error { color: #f48771; }
    .log-entry.success { color: #89d185; }
    .log-entry.info { color: #6796e6; }
    .tab-buttons {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
    }
    .tab-button {
      padding: 8px 16px;
      background: #e9ecef;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: #495057;
    }
    .tab-button.active {
      background: #4a90d9;
      color: white;
    }
    .hint-box {
      background: #f8f9fa;
      border-left: 4px solid #4a90d9;
      padding: 10px 15px;
      margin: 10px 0;
      font-size: 13px;
    }
    .result-section {
      margin-bottom: 15px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 4px;
    }
    .result-section h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #4a90d9;
      border-bottom: 1px solid #ddd;
      padding-bottom: 5px;
    }
    .result-row {
      display: flex;
      margin-bottom: 6px;
      word-break: break-all;
    }
    .result-label {
      font-weight: 600;
      min-width: 140px;
      color: #555;
    }
    .result-value {
      flex: 1;
      color: #333;
    }
    .result-value.hash {
      font-family: monospace;
      font-size: 12px;
      background: #e9ecef;
      padding: 2px 6px;
      border-radius: 3px;
    }
    .result-value a {
      color: #4a90d9;
      text-decoration: none;
    }
    .result-value a:hover {
      text-decoration: underline;
    }
    .success-banner {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 15px;
      text-align: center;
      font-weight: 600;
    }
    .tx-type-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .tx-type-badge.l1 { background: #cce5ff; color: #004085; }
    .tx-type-badge.l1-to-l2 { background: #d4edda; color: #155724; }
    .tx-type-badge.l2 { background: #fff3cd; color: #856404; }
    .refresh-indicator {
      display: inline-block;
      font-size: 12px;
      color: #666;
      margin-left: 10px;
    }
    .refresh-indicator.loading {
      color: #4a90d9;
    }
  </style>
</head>
<body>
  <h1>Synchronous Rollup Dashboard</h1>

  <!-- Status Dashboard Card -->
  <div class="card">
    <h2>
      Chain Status
      <span>
        <span id="refreshIndicator" class="refresh-indicator"></span>
        <button class="small secondary" id="refreshStatusBtn">Refresh</button>
      </span>
    </h2>

    <div class="dashboard-grid">
      <!-- L1 Status -->
      <div class="chain-status">
        <h3>L1 (Anvil - Chain 31337)</h3>
        <div class="status-row">
          <span class="status-label">Block Number</span>
          <span class="status-value" id="l1BlockNumber">-</span>
        </div>
        <div class="status-row">
          <span class="status-label">L2 State (in contract)</span>
          <span class="status-value hash copyable" id="l2StateInContract" title="" onclick="copyToClipboard(this)">-</span>
        </div>
        <div class="status-row">
          <span class="status-label">L2 Block (in contract)</span>
          <span class="status-value" id="l2BlockInContract">-</span>
        </div>
      </div>

      <!-- L2 Status -->
      <div class="chain-status l2">
        <h3>L2 (Native Rollup - Chain 10200200)</h3>
        <div class="status-row">
          <span class="status-label">Block Number</span>
          <span class="status-value" id="l2BlockNumber">-</span>
        </div>
        <div class="status-row">
          <span class="status-label">State Root</span>
          <span class="status-value hash copyable" id="l2StateRoot" title="" onclick="copyToClipboard(this)">-</span>
        </div>
        <div class="status-row">
          <span class="status-label">State Match</span>
          <span class="status-value" id="stateMatch">-</span>
        </div>
      </div>
    </div>

    <!-- SyncedCounter Status -->
    <div class="dashboard-grid" style="margin-top: 20px;">
      <!-- L1 SyncedCounter -->
      <div class="chain-status">
        <h3>L1 SyncedCounter</h3>
        <div class="status-row">
          <span class="status-label">Address</span>
          <span class="status-value hash copyable" id="l1CounterAddress" title="0x663F3ad617193148711d28f5334eE4Ed07016602" onclick="copyToClipboard(this)">0x663F...602</span>
        </div>
        <div class="status-row">
          <span class="status-label">Value</span>
          <span class="status-value" id="l1CounterValue">-</span>
        </div>
        <div class="status-row">
          <span class="status-label">L2 Contract Proxy</span>
          <span class="status-value hash copyable" id="l1CounterL2Proxy" title="" onclick="copyToClipboard(this)">-</span>
        </div>
      </div>

      <!-- L2 SyncedCounter -->
      <div class="chain-status l2">
        <h3>L2 SyncedCounter</h3>
        <div class="status-row">
          <span class="status-label">Address</span>
          <span class="status-value hash copyable" id="l2CounterAddress" title="0x663F3ad617193148711d28f5334eE4Ed07016602" onclick="copyToClipboard(this)">0x663F...602</span>
        </div>
        <div class="status-row">
          <span class="status-label">Value</span>
          <span class="status-value" id="l2CounterValue">-</span>
        </div>
        <div class="status-row">
          <span class="status-label">L1 Contract Proxy</span>
          <span class="status-value hash copyable" id="l2CounterL1Proxy" title="" onclick="copyToClipboard(this)">-</span>
        </div>
      </div>
    </div>

    <div class="status-row" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
      <span class="status-label">Counter Sync Status</span>
      <span class="status-value" id="counterSyncStatus">-</span>
    </div>

    <!-- L2 State History -->
    <h3 style="margin-top: 20px; margin-bottom: 10px; font-size: 14px; color: #555;">
      L2 State History
      <button class="toggle-btn" id="refreshHistory" style="margin-left: 10px;">Refresh</button>
    </h3>
    <div class="state-history-container" style="max-height: 300px; overflow-y: auto; background: #f8f9fa; border-radius: 8px; padding: 10px;">
      <div id="stateHistoryContent">
        <div style="text-align: center; color: #999; padding: 20px;">Loading state history...</div>
      </div>
    </div>

    <!-- Account Balances -->
    <h3 style="margin-top: 20px; margin-bottom: 10px; font-size: 14px; color: #555;">Account Balances</h3>
    <table class="balances-table">
      <thead>
        <tr>
          <th>Address</th>
          <th>Name</th>
          <th>L1 Balance</th>
          <th>L2 Balance</th>
        </tr>
      </thead>
      <tbody id="balancesBody">
        <tr><td colspan="4" style="text-align: center; color: #999;">Loading...</td></tr>
      </tbody>
    </table>
  </div>

  <!-- Settings Card (Collapsed by default) -->
  <div class="card">
    <h2>
      Settings
      <button class="toggle-btn" id="toggleSettings">Show</button>
    </h2>
    <div id="settingsContent" class="collapsible-content collapsed">
      <table style="width:100%; border-collapse:collapse; font-size:13px;">
        <thead>
          <tr style="text-align:left; border-bottom:1px solid #333;">
            <th style="padding:4px 8px;">Service</th>
            <th style="padding:4px 8px;">URL / Address</th>
            <th style="padding:4px 8px;">Status</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="padding:4px 8px;">L1 Anvil</td>
            <td style="padding:4px 8px;"><input type="text" id="l1Rpc" value="http://localhost:8545" style="width:100%;" /></td>
            <td style="padding:4px 8px;"><span id="statusL1Anvil" class="status-value">—</span></td>
          </tr>
          <tr>
            <td style="padding:4px 8px;">L1 Proxy</td>
            <td style="padding:4px 8px;"><input type="text" id="l1ProxyRpc" value="http://localhost:8546" style="width:100%;" /></td>
            <td style="padding:4px 8px;"><span id="statusL1Proxy" class="status-value">—</span></td>
          </tr>
          <tr>
            <td style="padding:4px 8px;">Fullnode (L2)</td>
            <td style="padding:4px 8px;"><input type="text" id="l2Rpc" value="http://localhost:9547" style="width:100%;" /></td>
            <td style="padding:4px 8px;"><span id="statusFullnode" class="status-value">—</span></td>
          </tr>
          <tr>
            <td style="padding:4px 8px;">L2 Proxy</td>
            <td style="padding:4px 8px;"><input type="text" id="l2ProxyRpc" value="http://localhost:9548" style="width:100%;" /></td>
            <td style="padding:4px 8px;"><span id="statusL2Proxy" class="status-value">—</span></td>
          </tr>
          <tr>
            <td style="padding:4px 8px;">Builder</td>
            <td style="padding:4px 8px;"><input type="text" id="builderUrl" value="http://localhost:3200" style="width:100%;" /></td>
            <td style="padding:4px 8px;"><span id="statusBuilder" class="status-value">—</span></td>
          </tr>
        </tbody>
      </table>
      <div class="row" style="margin-top:8px;">
        <div class="form-group">
          <label>Rollup Contract Address</label>
          <input type="text" id="rollupAddress" value="0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512" />
        </div>
      </div>
    </div>
  </div>

  <!-- Wallet Connection Card -->
  <div class="card">
    <h2>Wallet Connection</h2>
    <div class="row">
      <div class="form-group">
        <label>Connect To</label>
        <select id="connectChain">
          <option value="L1">L1 (Ethereum/Gnosis)</option>
          <option value="L2">L2 (Native Rollup)</option>
        </select>
      </div>
      <div class="form-group" style="display: flex; align-items: flex-end;">
        <button id="connectBtn">Connect Wallet</button>
      </div>
    </div>
    <div id="connectionStatus" class="status info hidden"></div>
  </div>

  <!-- Transaction Card -->
  <div class="card">
    <h2>Send Transaction</h2>

    <div class="hint-box" id="txHint">
      <strong>Connected to L1:</strong> Your transaction will be sent on L1.
      If the target is on L2, it will be routed through the proxy system.
    </div>

    <div class="form-group">
      <label>To Address</label>
      <select id="contractSelect" style="margin-bottom: 6px;">
        <option value="">-- Select a contract --</option>
        <optgroup label="L1 Contracts">
          <option value="0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512" data-chain="L1">NativeRollupCore</option>
          <option value="0x663F3ad617193148711d28f5334eE4Ed07016602" data-chain="L1">L1 SyncedCounter</option>
          <option value="0xa513E6E4b8f2a923D98304ec87F64353C4D5C853" data-chain="L1">SyncDemo</option>
        </optgroup>
        <optgroup label="L2 Contracts">
          <option value="0x663F3ad617193148711d28f5334eE4Ed07016602" data-chain="L2" data-l2="true">L2 SyncedCounter</option>
        </optgroup>
        <option value="custom">Custom address...</option>
      </select>
      <input type="text" id="toAddress" placeholder="0x..." />
      <div class="checkbox-group" style="margin-top: 8px;">
        <input type="checkbox" id="isL2Target" />
        <label for="isL2Target" style="margin: 0; font-weight: normal;">
          Target is on <span id="targetChainLabel">L2</span> (translate to proxy address)
        </label>
      </div>
      <div id="codeCheckInfo" class="hidden" style="margin-bottom:6px; font-size:12px;"></div>
      <div id="proxyInfo" class="proxy-info hidden">
        Proxy address: <code id="proxyAddress"></code>
      </div>
    </div>

    <div class="row">
      <div class="form-group">
        <label>Value (ETH)</label>
        <input type="text" id="txValue" value="0" placeholder="0.0" />
      </div>
      <div class="form-group">
        <label>Gas Limit (optional)</label>
        <input type="text" id="gasLimit" placeholder="auto" />
      </div>
    </div>

    <div class="form-group">
      <label>Call Data</label>
      <div class="tab-buttons">
        <button type="button" class="tab-button active" data-tab="raw">Raw Hex</button>
        <button type="button" class="tab-button" data-tab="abi">ABI Encoder</button>
      </div>
      <div id="rawDataTab">
        <textarea id="rawData" placeholder="0x (empty for simple transfer)">0x</textarea>
      </div>
      <div id="abiTab" class="hidden">
        <div class="form-group">
          <label>Function Signature</label>
          <input type="text" id="functionSig" placeholder="transfer(address,uint256)" value="setValue(uint256)" />
        </div>
        <div class="form-group">
          <label>Parameters (comma separated)</label>
          <input type="text" id="functionParams" placeholder="0x123..., 1000000000000000000" />
        </div>
        <button type="button" id="encodeBtn" class="secondary">Encode</button>
        <div id="encodedResult" class="status info hidden"></div>
      </div>
    </div>

    <div id="txSummary" class="hint-box">
      Connect wallet and fill in transaction details above.
    </div>
    <button id="submitBtn" disabled>Sign & Submit</button>
    <div id="submitStatus" class="status hidden"></div>
  </div>

  <!-- Transaction Result Card -->
  <div class="card hidden" id="txResultCard">
    <h2>Transaction Result</h2>
    <div id="txResult" style="font-family: monospace; font-size: 13px;">
    </div>
  </div>

  <!-- Logs Card -->
  <div class="card">
    <h2>
      Logs
      <button class="toggle-btn" id="toggleLogs">Hide</button>
    </h2>
    <div id="logsContent">
      <div id="logs"></div>
    </div>
  </div>

  <script>
    // ============ Configuration ============
    const TEST_ADDRESSES = [
      { address: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', name: 'Deployer (Anvil #0)' },
      { address: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', name: 'Proposer (Anvil #1)' },
      { address: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC', name: 'Prover (Anvil #2)' },
      { address: '0x7B2e78D4dFaABA045A167a70dA285E30E8FcA196', name: 'Custom Test' },
    ];

    // ============ State ============
    let provider = null;
    let signer = null;
    let rollupContract = null;
    let connectedChain = 'L1';
    let walletAddress = null;
    let statusRefreshInterval = null;

    const ROLLUP_ABI = [
      "function l2BlockHash() view returns (bytes32)",
      "function l2BlockNumber() view returns (uint256)",
      "function getProxyAddress(address l2Address) view returns (address)",
      "function isProxyDeployed(address l2Address) view returns (bool)",
      "event L2BlockProcessed(uint256 indexed blockNumber, bytes32 indexed prevBlockHash, bytes32 indexed newBlockHash, bytes rlpEncodedTx, tuple(address from, address target, uint256 value, uint256 gas, bytes data, bytes32 postCallStateHash)[] outgoingCalls, bytes[] outgoingCallResults)",
      "event IncomingCallHandled(address indexed l2Address, address indexed l1Caller, bytes32 indexed prevBlockHash, bytes callData, uint256 value, tuple(address from, address target, uint256 value, uint256 gas, bytes data, bytes32 postCallStateHash)[] outgoingCalls, bytes[] outgoingCallResults, bytes32 finalStateHash)",
    ];

    const SYNCED_COUNTER_ABI = [
      "function value() view returns (uint256)",
      "function l1ContractProxy() view returns (address)",
    ];

    function copyBlockRaw(idx) {
      const block = window._stateChainRaw?.[idx];
      if (!block) return;
      // Serialize with BigInt support
      const raw = JSON.stringify(block, (k, v) => typeof v === 'bigint' ? v.toString() : v, 2);
      navigator.clipboard.writeText(raw).then(() => {
        const btn = document.querySelectorAll('[onclick^="copyBlockRaw"]')[idx];
        if (btn) { const orig = btn.textContent; btn.textContent = 'Copied!'; setTimeout(() => btn.textContent = orig, 1500); }
      });
    }

    // SyncedCounter addresses from start.sh
    const L1_SYNCED_COUNTER = '0x663F3ad617193148711d28f5334eE4Ed07016602';
    const L2_SYNCED_COUNTER = '0x663F3ad617193148711d28f5334eE4Ed07016602';

    // ============ Network Configuration ============
    const NETWORKS = {
      L1: {
        chainId: '0x7A69',
        chainName: 'Anvil L1 via Proxy',
        rpcUrls: ['http://localhost:8546'],
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      },
      L2: {
        chainId: '0x9BA488',
        chainName: 'Native Rollup L2 via Proxy',
        rpcUrls: ['http://localhost:9548'],
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      },
    };

    function getRpcProxyUrl() { return document.getElementById('l1ProxyRpc').value; }
    const RPC_PROXY_URL = 'http://localhost:8546'; // legacy ref
    const PROXY_DETECTION_ADDRESS = '0x00000000000000000000000050524f5859525043';
    const PROXY_DETECTION_MAGIC_BALANCE = BigInt('0x50524f5859525043');
    const L2_PROXY_DETECTION_ADDRESS = '0x0000000000000000000000004c3250524f585952';
    const L2_PROXY_DETECTION_MAGIC_BALANCE = BigInt('0x4c3250524f585952');

    // ============ Copy to Clipboard ============
    function copyToClipboard(element) {
      const text = element.title || element.textContent;
      navigator.clipboard.writeText(text).then(() => {
        // Show tooltip
        let tooltip = element.querySelector('.copy-tooltip');
        if (!tooltip) {
          tooltip = document.createElement('span');
          tooltip.className = 'copy-tooltip';
          element.style.position = 'relative';
          element.appendChild(tooltip);
        }
        tooltip.textContent = 'Copied!';
        tooltip.classList.add('show');
        setTimeout(() => tooltip.classList.remove('show'), 1500);
      }).catch(err => {
        console.error('Copy failed:', err);
      });
    }

    // ============ Logging ============
    function log(message, type = 'info') {
      const logs = document.getElementById('logs');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const time = new Date().toLocaleTimeString();
      entry.textContent = `[${time}] ${message}`;
      logs.appendChild(entry);
      logs.scrollTop = logs.scrollHeight;
    }

    function showStatus(elementId, message, type) {
      const el = document.getElementById(elementId);
      el.textContent = message;
      el.className = `status ${type}`;
      el.classList.remove('hidden');
    }

    // ============ Status Dashboard ============
    async function checkServiceHealth() {
      const services = [
        { id: 'statusL1Anvil', url: document.getElementById('l1Rpc').value },
        { id: 'statusL1Proxy', url: document.getElementById('l1ProxyRpc').value },
        { id: 'statusFullnode', url: document.getElementById('l2Rpc').value },
        { id: 'statusL2Proxy', url: document.getElementById('l2ProxyRpc').value },
        { id: 'statusBuilder', url: document.getElementById('builderUrl').value, path: '/status' },
      ];

      await Promise.all(services.map(async (svc) => {
        const el = document.getElementById(svc.id);
        try {
          const url = svc.path ? svc.url + svc.path : svc.url;
          const body = svc.path ? undefined : JSON.stringify({ jsonrpc: '2.0', method: 'eth_blockNumber', params: [], id: 1 });
          const resp = await fetch(url, {
            method: svc.path ? 'GET' : 'POST',
            headers: svc.path ? {} : { 'Content-Type': 'application/json' },
            body,
            signal: AbortSignal.timeout(2000),
          });
          if (resp.ok) {
            el.textContent = '● Online';
            el.className = 'status-value match';
          } else {
            el.textContent = '○ Error';
            el.className = 'status-value mismatch';
          }
        } catch {
          el.textContent = '○ Offline';
          el.className = 'status-value mismatch';
        }
      }));
    }

    async function refreshStatus() {
      const indicator = document.getElementById('refreshIndicator');
      indicator.textContent = 'Refreshing...';
      indicator.className = 'refresh-indicator loading';

      checkServiceHealth();

      try {
        const l1Rpc = document.getElementById('l1Rpc').value;
        const l2Rpc = document.getElementById('l2Rpc').value;
        const rollupAddr = document.getElementById('rollupAddress').value;

        const l1Provider = new ethers.JsonRpcProvider(l1Rpc);
        const l2Provider = new ethers.JsonRpcProvider(l2Rpc);
        const rollup = new ethers.Contract(rollupAddr, ROLLUP_ABI, l1Provider);

        // Fetch all data in parallel
        // Note: ethers.js getBlock() doesn't expose stateRoot, so we use raw RPC call
        const [l1BlockNum, l2StateContract, l2BlockContract, l2BlockRaw] = await Promise.all([
          l1Provider.getBlockNumber(),
          rollup.l2BlockHash(),
          rollup.l2BlockNumber(),
          l2Provider.send('eth_getBlockByNumber', ['latest', false]),
        ]);

        // Update L1 status
        document.getElementById('l1BlockNumber').textContent = l1BlockNum;
        document.getElementById('l2StateInContract').textContent = l2StateContract.slice(0, 18) + '...';
        document.getElementById('l2StateInContract').title = l2StateContract;
        document.getElementById('l2BlockInContract').textContent = l2BlockContract.toString();

        // Update L2 status (use raw RPC response which includes stateRoot)
        const l2BlockNumber = l2BlockRaw?.number ? parseInt(l2BlockRaw.number, 16) : '-';
        document.getElementById('l2BlockNumber').textContent = l2BlockNumber;
        const l2StateRoot = l2BlockRaw?.stateRoot || '-';
        document.getElementById('l2StateRoot').textContent = l2StateRoot !== '-' ? l2StateRoot.slice(0, 18) + '...' : '-';
        document.getElementById('l2StateRoot').title = l2StateRoot;

        // Check state match
        const stateMatchEl = document.getElementById('stateMatch');
        if (l2StateContract === '0x0000000000000000000000000000000000000000000000000000000000000000') {
          stateMatchEl.textContent = 'NO STATE';
          stateMatchEl.className = 'status-value mismatch';
        } else if (l2StateContract.toLowerCase() === l2StateRoot.toLowerCase()) {
          stateMatchEl.textContent = 'SYNCED';
          stateMatchEl.className = 'status-value match';
        } else {
          stateMatchEl.textContent = 'DIVERGED';
          stateMatchEl.className = 'status-value mismatch';
        }

        // Update balances
        await updateBalancesTable(l1Provider, l2Provider);

        // Update SyncedCounter info
        await updateSyncedCounterInfo(l1Provider, l2Provider, rollup);

        indicator.textContent = `Updated ${new Date().toLocaleTimeString()}`;
        indicator.className = 'refresh-indicator';

      } catch (err) {
        log(`Status refresh failed: ${err.message}`, 'error');
        indicator.textContent = 'Error';
        indicator.className = 'refresh-indicator';
      }
    }

    async function updateBalancesTable(l1Provider, l2Provider) {
      const tbody = document.getElementById('balancesBody');

      try {
        const balancePromises = TEST_ADDRESSES.map(async (acc) => {
          const [l1Bal, l2Bal] = await Promise.all([
            l1Provider.getBalance(acc.address),
            l2Provider.getBalance(acc.address),
          ]);
          return {
            ...acc,
            l1Balance: ethers.formatEther(l1Bal),
            l2Balance: ethers.formatEther(l2Bal),
          };
        });

        const balances = await Promise.all(balancePromises);

        tbody.innerHTML = balances.map(acc => `
          <tr>
            <td class="address copyable" title="${acc.address}" onclick="copyToClipboard(this)">${acc.address.slice(0, 10)}...${acc.address.slice(-6)}</td>
            <td>${acc.name}</td>
            <td>${parseFloat(acc.l1Balance).toFixed(4)} ETH</td>
            <td>${parseFloat(acc.l2Balance).toFixed(4)} ETH</td>
          </tr>
        `).join('');

      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: #dc3545;">Error: ${err.message}</td></tr>`;
      }
    }

    // ============ SyncedCounter Info ============
    async function updateSyncedCounterInfo(l1Provider, l2Provider, rollup) {
      try {
        const l1Counter = new ethers.Contract(L1_SYNCED_COUNTER, SYNCED_COUNTER_ABI, l1Provider);
        const l2Counter = new ethers.Contract(L2_SYNCED_COUNTER, SYNCED_COUNTER_ABI, l2Provider);

        // Fetch counter values and proxy addresses in parallel
        const [l1Value, l2Value, l1ProxyOnL2] = await Promise.all([
          l1Counter.value().catch(() => null),
          l2Counter.value().catch(() => null),
          rollup.getProxyAddress(L1_SYNCED_COUNTER).catch(() => null),
        ]);

        // Try to get L2's l1ContractProxy setting
        let l2ProxyOnL1 = null;
        try {
          l2ProxyOnL1 = await l2Counter.l1ContractProxy();
        } catch (e) {
          // Contract might not have this function
        }

        // Update L1 Counter display
        document.getElementById('l1CounterValue').textContent = l1Value !== null ? l1Value.toString() : 'N/A';
        if (l1ProxyOnL2) {
          const shortProxy = l1ProxyOnL2.slice(0, 8) + '...' + l1ProxyOnL2.slice(-4);
          document.getElementById('l1CounterL2Proxy').textContent = shortProxy;
          document.getElementById('l1CounterL2Proxy').title = l1ProxyOnL2;
        } else {
          document.getElementById('l1CounterL2Proxy').textContent = 'N/A';
        }

        // Update L2 Counter display
        document.getElementById('l2CounterValue').textContent = l2Value !== null ? l2Value.toString() : 'N/A';
        if (l2ProxyOnL1) {
          const shortProxy = l2ProxyOnL1.slice(0, 8) + '...' + l2ProxyOnL1.slice(-4);
          document.getElementById('l2CounterL1Proxy').textContent = shortProxy;
          document.getElementById('l2CounterL1Proxy').title = l2ProxyOnL1;
        } else {
          document.getElementById('l2CounterL1Proxy').textContent = 'Not set';
        }

        // Update sync status
        const syncStatusEl = document.getElementById('counterSyncStatus');
        if (l1Value !== null && l2Value !== null) {
          if (l1Value.toString() === l2Value.toString()) {
            syncStatusEl.textContent = `SYNCED (both = ${l1Value})`;
            syncStatusEl.className = 'status-value match';
          } else {
            syncStatusEl.textContent = `OUT OF SYNC (L1=${l1Value}, L2=${l2Value})`;
            syncStatusEl.className = 'status-value mismatch';
          }
        } else if (l1Value === null && l2Value === null) {
          syncStatusEl.textContent = 'Contracts not deployed';
          syncStatusEl.className = 'status-value';
        } else {
          syncStatusEl.textContent = 'Partial deployment';
          syncStatusEl.className = 'status-value mismatch';
        }

      } catch (err) {
        log(`SyncedCounter refresh failed: ${err.message}`, 'error');
        document.getElementById('l1CounterValue').textContent = 'Error';
        document.getElementById('l2CounterValue').textContent = 'Error';
        document.getElementById('counterSyncStatus').textContent = 'Error';
        document.getElementById('counterSyncStatus').className = 'status-value mismatch';
      }
    }

    // ============ Calldata Decoder ============
    const KNOWN_FUNCTIONS = {
      '0x55241077': { name: 'setValue', sig: 'setValue(uint256)', params: ['uint256'] },
      '0x96fc4414': { name: 'setL2Proxy', sig: 'setL2Proxy(address)', params: ['address'] },
      '0x549290ad': { name: 'setL1ContractProxy', sig: 'setL1ContractProxy(address)', params: ['address'] },
      '0xec63d87f': { name: 'setL1Counter', sig: 'setL1Counter(address)', params: ['address'] },
      '0x3fa4f245': { name: 'value', sig: 'value()', params: [] },
    };

    function decodeCalldata(data) {
      if (!data || data.length < 10) {
        return { decoded: false, raw: data || '0x' };
      }

      // Normalize: ensure lowercase and proper 0x prefix
      const normalizedData = data.toLowerCase();
      const selector = normalizedData.slice(0, 10);
      const funcInfo = KNOWN_FUNCTIONS[selector];

      // Debug logging (can be removed later)
      // console.log('Decoding:', { data, selector, found: !!funcInfo });

      if (!funcInfo) {
        return { decoded: false, raw: data, selector };
      }

      try {
        const abiCoder = ethers.AbiCoder.defaultAbiCoder();
        const paramsData = '0x' + normalizedData.slice(10);

        if (funcInfo.params.length === 0) {
          return {
            decoded: true,
            name: funcInfo.name,
            sig: funcInfo.sig,
            args: [],
            formatted: `${funcInfo.name}()`
          };
        }

        const decoded = abiCoder.decode(funcInfo.params, paramsData);
        const args = decoded.map((arg, i) => {
          if (funcInfo.params[i] === 'address') {
            return arg;
          } else if (funcInfo.params[i] === 'uint256') {
            return arg.toString();
          }
          return arg.toString();
        });

        return {
          decoded: true,
          name: funcInfo.name,
          sig: funcInfo.sig,
          args,
          formatted: `${funcInfo.name}(${args.join(', ')})`
        };
      } catch (e) {
        return { decoded: false, raw: data, selector, error: e.message };
      }
    }

    function formatCalldata(data, value) {
      const decoded = decodeCalldata(data);
      const valueStr = value && value > 0n ? ` {value: ${ethers.formatEther(value)} ETH}` : '';

      if (decoded.decoded) {
        return `<span class="decoded-call" style="color: #28a745; font-weight: 500;">${decoded.formatted}</span>${valueStr}`;
      } else if (decoded.selector) {
        return `<code class="copyable" title="${data}" onclick="copyToClipboard(this)">${decoded.selector}...</code>${valueStr}`;
      } else {
        return `<code class="copyable" title="${data}" onclick="copyToClipboard(this)">${decoded.raw}</code>${valueStr}`;
      }
    }

    // ============ L2 State History ============
    async function refreshStateHistory() {
      const container = document.getElementById('stateHistoryContent');

      try {
        const l1Rpc = document.getElementById('l1Rpc').value;
        const rollupAddr = document.getElementById('rollupAddress').value;

        const l1Provider = new ethers.JsonRpcProvider(l1Rpc);
        const rollup = new ethers.Contract(rollupAddr, ROLLUP_ABI, l1Provider);

        // Get current state
        const currentStateHash = await rollup.l2BlockHash();

        // Query both event types
        const [l2BlockEvents, incomingCallEvents] = await Promise.all([
          rollup.queryFilter(rollup.filters.L2BlockProcessed(), 0, 'latest'),
          rollup.queryFilter(rollup.filters.IncomingCallHandled(), 0, 'latest'),
        ]);

        // Build unified state chain
        const stateChain = [];

        // Add genesis (block 0) - use first L2BlockProcessed event's prevBlockHash
        if (l2BlockEvents.length > 0) {
          const firstEvent = l2BlockEvents[0];
          stateChain.push({
            eventType: 'genesis',
            prevHash: null,
            newHash: firstEvent.args.prevBlockHash,
            l1Block: null,
            l1Timestamp: null,
            txHash: null,
          });
        }

        // Process L2BlockProcessed events
        for (const event of l2BlockEvents) {
          const l1Block = await l1Provider.getBlock(event.blockNumber);

          // Decode the RLP-encoded L2 transaction
          let txFrom = null, txTo = null, txData = null, txValue = null;
          try {
            const decodedTx = ethers.Transaction.from(event.args.rlpEncodedTx);
            txFrom = decodedTx.from;
            txTo = decodedTx.to;
            txData = decodedTx.data;
            txValue = decodedTx.value;
          } catch (e) {
            console.log('Failed to decode tx:', e);
          }

          stateChain.push({
            eventType: 'L2BlockProcessed',
            blockNumber: Number(event.args.blockNumber),
            prevHash: event.args.prevBlockHash,
            newHash: event.args.newBlockHash,
            l1Block: event.blockNumber,
            l1Timestamp: l1Block ? new Date(l1Block.timestamp * 1000) : null,
            txHash: event.transactionHash,
            outgoingCalls: event.args.outgoingCalls || [],
            outgoingCallResults: event.args.outgoingCallResults || [],
            txFrom,
            txTo,
            txData,
            txValue,
          });
        }

        // Process IncomingCallHandled events
        for (const event of incomingCallEvents) {
          const l1Block = await l1Provider.getBlock(event.blockNumber);

          stateChain.push({
            eventType: 'IncomingCallHandled',
            prevHash: event.args.prevBlockHash,
            newHash: event.args.finalStateHash,
            l1Block: event.blockNumber,
            l1Timestamp: l1Block ? new Date(l1Block.timestamp * 1000) : null,
            txHash: event.transactionHash,
            outgoingCalls: event.args.outgoingCalls || [],
            outgoingCallResults: event.args.outgoingCallResults || [],
            l2Address: event.args.l2Address,
            l1Caller: event.args.l1Caller,
            txData: event.args.callData,
            txValue: event.args.value,
          });
        }

        // Sort by L1 block number, then by transaction index within block
        stateChain.sort((a, b) => {
          if (a.eventType === 'genesis') return -1;
          if (b.eventType === 'genesis') return 1;
          if (a.l1Block !== b.l1Block) return a.l1Block - b.l1Block;
          // If same block, maintain order by tx hash (approximation)
          return (a.txHash || '').localeCompare(b.txHash || '');
        });

        // Render state chain (genesis first, then chronological order)
        if (stateChain.length === 0) {
          container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">No L2 blocks processed yet</div>';
          return;
        }

        // Store raw data for copy button
        window._stateChainRaw = stateChain;

        const html = stateChain.map((block, idx) => {
          const copyBtnHtml = `<button onclick="copyBlockRaw(${idx})" style="float:right;font-size:10px;padding:2px 6px;cursor:pointer;background:#444;color:#fff;border:1px solid #666;border-radius:3px;">Copy Raw</button>`;

          const shortPrev = block.prevHash ? block.prevHash.slice(0, 10) + '...' + block.prevHash.slice(-6) : 'Genesis';
          const shortNew = block.newHash.slice(0, 10) + '...' + block.newHash.slice(-6);
          const isCurrentState = block.newHash.toLowerCase() === currentStateHash.toLowerCase();

          // Genesis block
          if (block.eventType === 'genesis') {
            return `
              <div class="state-block genesis">
                <div class="block-header">
                  <span class="block-number">Genesis State (Block #0)</span>
                  ${copyBtnHtml}
                </div>
                <div class="state-transition">
                  <span class="hash copyable" title="${block.newHash}" onclick="copyToClipboard(this)">${shortNew}</span>
                  ${isCurrentState ? '<span style="color: #28a745; font-weight: 600;">← Current</span>' : ''}
                </div>
              </div>
            `;
          }

          const timeStr = block.l1Timestamp ? block.l1Timestamp.toLocaleTimeString() : '';

          // Format outgoing calls if any
          let outgoingCallsHtml = '';
          if (block.outgoingCalls && block.outgoingCalls.length > 0) {
            const results = block.outgoingCallResults || [];
            outgoingCallsHtml = `
              <div class="outgoing-calls" style="margin-top: 6px; padding-top: 6px; border-top: 1px dashed #ddd;">
                <span style="font-size: 10px; color: #666;">L2→L1 Calls (${block.outgoingCalls.length}):</span>
                ${block.outgoingCalls.map((call, i) => {
                  const callTo = call.target ? call.target.slice(0, 8) + '...' + call.target.slice(-4) : 'N/A';
                  const callDataHtml = formatCalldata(call.data, call.value);
                  const resultData = results[i];
                  let resultHtml = '';
                  if (resultData && resultData !== '0x') {
                    const shortResult = resultData.length > 20 ? resultData.slice(0, 20) + '...' : resultData;
                    resultHtml = ` <span style="color: #17a2b8;">⇒ <code class="copyable" title="${resultData}" onclick="copyToClipboard(this)">${shortResult}</code></span>`;
                  }
                  return `<div style="font-size: 11px; margin-left: 10px;">
                    #${i+1}: → <code class="copyable" title="${call.target}" onclick="copyToClipboard(this)">${callTo}</code>
                    ${callDataHtml}${resultHtml}
                  </div>`;
                }).join('')}
              </div>
            `;
          }

          // L2BlockProcessed event (L2 transaction)
          if (block.eventType === 'L2BlockProcessed') {
            const shortFrom = block.txFrom ? block.txFrom.slice(0, 8) + '...' + block.txFrom.slice(-4) : 'N/A';
            const shortTo = block.txTo ? block.txTo.slice(0, 8) + '...' + block.txTo.slice(-4) : '(deploy)';
            const calldataHtml = formatCalldata(block.txData, block.txValue);

            return `
              <div class="state-block l2-block">
                <div class="block-header">
                  <span class="block-number">
                    L2 Block #${block.blockNumber}
                    <span class="event-type l2-tx">L2 TX</span>
                  </span>
                  <span class="block-time">${timeStr} (L1 #${block.l1Block})</span>
                  ${copyBtnHtml}
                </div>
                <div class="state-transition">
                  <span class="hash copyable" title="${block.prevHash}" onclick="copyToClipboard(this)">${shortPrev}</span>
                  <span class="arrow">→</span>
                  <span class="hash copyable" title="${block.newHash}" onclick="copyToClipboard(this)">${shortNew}</span>
                  ${isCurrentState ? '<span style="color: #28a745; font-weight: 600;">← Current</span>' : ''}
                </div>
                <div class="tx-info">
                  <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <span>From: <code class="copyable" title="${block.txFrom}" onclick="copyToClipboard(this)">${shortFrom}</code></span>
                    <span>To: <code class="copyable" title="${block.txTo || ''}" onclick="copyToClipboard(this)">${shortTo}</code></span>
                  </div>
                  <div style="margin-top: 4px;">
                    Call: ${calldataHtml}
                  </div>
                  <div style="margin-top: 2px; font-size: 11px; color: #666;">
                    L1 TX: <code class="copyable" title="${block.txHash}" onclick="copyToClipboard(this)">${block.txHash?.slice(0, 10)}...</code>
                  </div>
                  ${outgoingCallsHtml}
                </div>
              </div>
            `;
          }

          // IncomingCallHandled event (L1→L2 call)
          if (block.eventType === 'IncomingCallHandled') {
            const shortL2Addr = block.l2Address ? block.l2Address.slice(0, 8) + '...' + block.l2Address.slice(-4) : 'N/A';
            const shortL1Caller = block.l1Caller ? block.l1Caller.slice(0, 8) + '...' + block.l1Caller.slice(-4) : 'N/A';
            const calldataHtml = formatCalldata(block.txData, block.txValue);

            return `
              <div class="state-block incoming-call">
                <div class="block-header">
                  <span class="block-number">
                    L1→L2 Call
                    <span class="event-type l1-to-l2">INCOMING</span>
                  </span>
                  <span class="block-time">${timeStr} (L1 #${block.l1Block})</span>
                  ${copyBtnHtml}
                </div>
                <div class="state-transition">
                  <span class="hash copyable" title="${block.prevHash}" onclick="copyToClipboard(this)">${shortPrev}</span>
                  <span class="arrow">→</span>
                  <span class="hash copyable" title="${block.newHash}" onclick="copyToClipboard(this)">${shortNew}</span>
                  ${isCurrentState ? '<span style="color: #28a745; font-weight: 600;">← Current</span>' : ''}
                </div>
                <div class="tx-info">
                  <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <span>L1 Caller: <code class="copyable" title="${block.l1Caller}" onclick="copyToClipboard(this)">${shortL1Caller}</code></span>
                    <span>L2 Target: <code class="copyable" title="${block.l2Address}" onclick="copyToClipboard(this)">${shortL2Addr}</code></span>
                  </div>
                  <div style="margin-top: 4px;">
                    Call: ${calldataHtml}
                  </div>
                  <div style="margin-top: 2px; font-size: 11px; color: #666;">
                    L1 TX: <code class="copyable" title="${block.txHash}" onclick="copyToClipboard(this)">${block.txHash?.slice(0, 10)}...</code>
                  </div>
                  ${outgoingCallsHtml}
                </div>
              </div>
            `;
          }

          return ''; // Unknown event type
        }).join('');

        container.innerHTML = html;

      } catch (err) {
        container.innerHTML = `<div style="text-align: center; color: #dc3545; padding: 20px;">Error: ${err.message}</div>`;
        log(`State history refresh failed: ${err.message}`, 'error');
      }
    }

    // ============ Settings Toggle ============
    document.getElementById('toggleSettings').addEventListener('click', (e) => {
      const content = document.getElementById('settingsContent');
      const btn = e.target;
      if (content.classList.contains('collapsed')) {
        content.classList.remove('collapsed');
        content.style.maxHeight = content.scrollHeight + 'px';
        btn.textContent = 'Hide';
      } else {
        content.classList.add('collapsed');
        content.style.maxHeight = '0';
        btn.textContent = 'Show';
      }
    });

    // ============ Logs Toggle ============
    document.getElementById('toggleLogs').addEventListener('click', (e) => {
      const content = document.getElementById('logsContent');
      const btn = e.target;
      if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        btn.textContent = 'Hide';
      } else {
        content.classList.add('hidden');
        btn.textContent = 'Show';
      }
    });

    // ============ Refresh Button ============
    document.getElementById('refreshStatusBtn').addEventListener('click', refreshStatus);

    // ============ Switch Network Helper ============
    async function switchToNetwork(networkKey) {
      const network = NETWORKS[networkKey];
      const chainIdHex = network.chainId;

      try {
        log(`Attempting to add/switch to ${network.chainName}...`, 'info');
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: chainIdHex,
            chainName: network.chainName,
            rpcUrls: network.rpcUrls,
            nativeCurrency: network.nativeCurrency,
          }],
        });
        log(`Added/switched to ${network.chainName}`, 'success');
        return true;
      } catch (addError) {
        log(`wallet_addEthereumChain error: ${addError.message}`, 'info');

        try {
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: chainIdHex }],
          });
          log(`Switched to ${network.chainName}`, 'success');
          return true;
        } catch (switchError) {
          log(`Please manually add network: Chain ID ${parseInt(chainIdHex, 16)}, RPC: ${network.rpcUrls[0]}`, 'error');
          return false;
        }
      }
    }

    // ============ Connection ============
    document.getElementById('connectBtn').addEventListener('click', async () => {
      try {
        if (!window.ethereum) {
          throw new Error('No wallet detected. Please install MetaMask or Rabby.');
        }

        log('Connecting wallet...');

        const accounts = await window.ethereum.request({
          method: 'eth_requestAccounts'
        });
        walletAddress = accounts[0];

        provider = new ethers.BrowserProvider(window.ethereum);
        const network = await provider.getNetwork();
        connectedChain = document.getElementById('connectChain').value;
        const expectedChainId = BigInt(NETWORKS[connectedChain].chainId);

        if (network.chainId !== expectedChainId) {
          log(`Wrong network, switching to ${connectedChain}...`, 'info');
          const switched = await switchToNetwork(connectedChain);
          if (switched) {
            provider = new ethers.BrowserProvider(window.ethereum);
          } else {
            showStatus('connectionStatus', `Failed to switch network`, 'error');
            return;
          }
        }

        signer = await provider.getSigner();
        const finalNetwork = await provider.getNetwork();

        const rollupAddr = document.getElementById('rollupAddress').value;
        const l1Rpc = document.getElementById('l1Rpc').value;
        const l1Provider = new ethers.JsonRpcProvider(l1Rpc);
        rollupContract = new ethers.Contract(rollupAddr, ROLLUP_ABI, l1Provider);

        log(`Connected: ${walletAddress}`, 'success');

        const isProxyConnected = await checkProxyConnection(connectedChain);

        let statusMsg = `Connected: ${walletAddress.slice(0,6)}...${walletAddress.slice(-4)} | ${connectedChain}`;
        let statusType = 'success';

        if (isProxyConnected) {
          statusMsg += ' | RPC Proxy';
        } else {
          statusMsg += ' | Direct RPC (Warning!)';
          statusType = 'error';
        }

        showStatus('connectionStatus', statusMsg, statusType);
        document.getElementById('submitBtn').disabled = false;
        updateUI();
        refreshStatus();

      } catch (err) {
        log(`Connection failed: ${err.message}`, 'error');
        showStatus('connectionStatus', err.message, 'error');
      }
    });

    // ============ Proxy Detection ============
    async function checkProxyConnection(chain = 'L1') {
      if (!provider) return false;

      try {
        const magicAddress = chain === 'L2' ? L2_PROXY_DETECTION_ADDRESS : PROXY_DETECTION_ADDRESS;
        const expectedBalance = chain === 'L2' ? L2_PROXY_DETECTION_MAGIC_BALANCE : PROXY_DETECTION_MAGIC_BALANCE;

        const balance = await provider.getBalance(magicAddress);
        const isProxy = balance === expectedBalance;

        if (isProxy) {
          log(`Connected to ${chain} RPC Proxy`, 'success');
        } else {
          log(`Warning: Direct RPC connection (not via proxy)`, 'error');
        }

        return isProxy;
      } catch (err) {
        log(`Proxy detection failed: ${err.message}`, 'error');
        return false;
      }
    }

    // ============ Chain Selection ============
    document.getElementById('connectChain').addEventListener('change', (e) => {
      connectedChain = e.target.value;
      updateUI();
    });

    function updateUI() {
      const isL1 = connectedChain === 'L1';
      const hint = document.getElementById('txHint');
      const targetLabel = document.getElementById('targetChainLabel');

      if (isL1) {
        hint.innerHTML = '<strong>Connected to L1:</strong> Transaction will be sent on L1. Check "Target is on L2" for cross-chain deposits.';
        targetLabel.textContent = 'L2';
      } else {
        hint.innerHTML = '<strong>Connected to L2:</strong> Transaction will be routed through L1 via processCallOnL2.';
        targetLabel.textContent = 'L1';
      }

      updateTxSummary();
    }

    // ============ Contract Dropdown ============
    document.getElementById('contractSelect').addEventListener('change', function() {
      const select = this;
      const option = select.options[select.selectedIndex];
      const toInput = document.getElementById('toAddress');
      const isL2Checkbox = document.getElementById('isL2Target');

      if (select.value === '' || select.value === 'custom') {
        if (select.value === 'custom') toInput.value = '';
        toInput.style.display = '';
        toInput.focus();
      } else {
        toInput.value = select.value;
        toInput.style.display = 'none';
        // Auto-set L2 target checkbox
        isL2Checkbox.checked = option.dataset.l2 === 'true';
      }
      updateProxyAddress();
      checkAddressCode();
      updateTransactionSummary();
    });
    // Initially hide manual input if a contract is selected
    document.getElementById('toAddress').style.display = '';

    // ============ Address Code Check ============
    async function checkAddressCode() {
      const el = document.getElementById('codeCheckInfo');
      const addr = document.getElementById('toAddress').value;
      if (!addr || !ethers.isAddress(addr)) {
        el.classList.add('hidden');
        return;
      }
      try {
        const l1Rpc = document.getElementById('l1Rpc').value;
        const p = new ethers.JsonRpcProvider(l1Rpc);
        const code = await p.getCode(addr);
        if (!code || code === '0x') {
          el.innerHTML = `⚠️ <strong>Warning:</strong> No contract code at <code>${addr.slice(0,8)}...${addr.slice(-4)}</code> on L1`;
          el.style.color = '#dc3545';
          el.classList.remove('hidden');
        } else {
          el.innerHTML = `✓ Contract found at <code>${addr.slice(0,8)}...${addr.slice(-4)}</code> (${code.length / 2 - 1} bytes)`;
          el.style.color = '#28a745';
          el.classList.remove('hidden');
        }
      } catch {
        el.classList.add('hidden');
      }
    }

    // ============ Proxy Address ============
    document.getElementById('toAddress').addEventListener('input', () => { updateProxyAddress(); checkAddressCode(); });
    document.getElementById('isL2Target').addEventListener('change', () => { updateProxyAddress(); checkAddressCode(); });

    async function updateProxyAddress() {
      const toAddr = document.getElementById('toAddress').value;
      const isL2Target = document.getElementById('isL2Target').checked;
      const proxyInfo = document.getElementById('proxyInfo');

      if (!isL2Target || !toAddr || !ethers.isAddress(toAddr)) {
        proxyInfo.classList.add('hidden');
        return;
      }

      try {
        const l1Rpc = document.getElementById('l1Rpc').value;
        const l1Prov = new ethers.JsonRpcProvider(l1Rpc);
        if (!rollupContract) {
          const rollupAddr = document.getElementById('rollupAddress').value;
          rollupContract = new ethers.Contract(rollupAddr, ROLLUP_ABI, l1Prov);
        }

        const proxyAddr = await rollupContract.getProxyAddress(toAddr);
        const proxyCode = await l1Prov.getCode(proxyAddr);
        const hasCode = proxyCode && proxyCode !== '0x' && proxyCode.length >= 10;

        // Store proxy address for tx submission
        proxyInfo.dataset.proxyAddr = proxyAddr;

        if (hasCode) {
          proxyInfo.style.background = '#fffbe6';
          proxyInfo.style.borderColor = '#ffe58f';
          proxyInfo.innerHTML = `Proxy address: <code>${proxyAddr}</code>`;
        } else {
          proxyInfo.style.background = '#fff1f0';
          proxyInfo.style.borderColor = '#ffa39e';
          proxyInfo.innerHTML = `⚠️ <strong>Warning:</strong> Proxy <code>${proxyAddr.slice(0,10)}...${proxyAddr.slice(-4)}</code> has <strong>no code</strong> yet. The builder will deploy it when you submit.`;
        }
        proxyInfo.classList.remove('hidden');
      } catch (err) {
        proxyInfo.classList.add('hidden');
      }

      updateTxSummary();
    }

    // ============ Data Tabs ============
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const tab = e.target.dataset.tab;
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        document.getElementById('rawDataTab').classList.toggle('hidden', tab !== 'raw');
        document.getElementById('abiTab').classList.toggle('hidden', tab !== 'abi');
      });
    });

    // ============ ABI Encoder ============
    document.getElementById('encodeBtn').addEventListener('click', () => {
      try {
        const sig = document.getElementById('functionSig').value.trim();
        const params = document.getElementById('functionParams').value.trim();

        if (!sig) throw new Error('Enter a function signature');

        const iface = new ethers.Interface([`function ${sig}`]);
        const funcName = sig.split('(')[0];
        let args = params ? params.split(',').map(p => p.trim()) : [];

        const encoded = iface.encodeFunctionData(funcName, args);
        document.getElementById('rawData').value = encoded;
        showStatus('encodedResult', `Encoded: ${encoded.slice(0, 20)}...`, 'success');
        updateTxSummary();
      } catch (err) {
        showStatus('encodedResult', `Error: ${err.message}`, 'error');
      }
    });

    // ============ Transaction Summary ============
    function updateTxSummary() {
      const summary = document.getElementById('txSummary');
      const toAddr = document.getElementById('toAddress').value;
      const isL2Target = document.getElementById('isL2Target').checked;
      const value = document.getElementById('txValue').value || '0';

      if (!walletAddress) {
        summary.textContent = 'Connect wallet to send transactions.';
        return;
      }

      const proxyAddr = document.getElementById('proxyInfo').dataset.proxyAddr || '';
      const actualTo = isL2Target && proxyAddr ? proxyAddr : toAddr;

      let html = `<strong>From:</strong> ${walletAddress.slice(0,10)}...<br>`;
      html += `<strong>To:</strong> ${actualTo || '(not set)'}<br>`;
      if (isL2Target) {
        html += `<em>(Proxy for L2: ${toAddr})</em><br>`;
      }
      html += `<strong>Value:</strong> ${value} ETH`;

      summary.innerHTML = html;
    }

    document.getElementById('txValue').addEventListener('input', updateTxSummary);
    document.getElementById('rawData').addEventListener('input', updateTxSummary);

    // ============ Submit Transaction ============
    document.getElementById('submitBtn').addEventListener('click', async () => {
      const submitBtn = document.getElementById('submitBtn');
      submitBtn.disabled = true;

      try {
        const toAddr = document.getElementById('toAddress').value;
        const isL2Target = document.getElementById('isL2Target').checked;
        const value = document.getElementById('txValue').value || '0';
        const data = document.getElementById('rawData').value || '0x';
        const builderUrl = document.getElementById('builderUrl').value;

        if (!toAddr || !ethers.isAddress(toAddr)) {
          throw new Error('Invalid "to" address');
        }

        let actualTo = toAddr;
        let hints = null;

        if (isL2Target) {
          let proxyAddr = document.getElementById('proxyInfo').dataset.proxyAddr;
          if (!proxyAddr) {
            // Try to compute it on the fly
            log('Proxy address not cached, computing...', 'info');
            const l1Rpc = document.getElementById('l1Rpc').value;
            const rollupAddr = document.getElementById('rollupAddress').value;
            const tmpProvider = new ethers.JsonRpcProvider(l1Rpc);
            const tmpRollup = new ethers.Contract(rollupAddr, ROLLUP_ABI, tmpProvider);
            proxyAddr = await tmpRollup.getProxyAddress(toAddr);
          }
          if (!proxyAddr) throw new Error('Could not get proxy address');
          actualTo = proxyAddr;
          hints = { l2TargetAddress: toAddr, description: `${connectedChain} tx to L2 address ${toAddr}` };
          log(`L2 target: ${toAddr} → proxy: ${proxyAddr}`, 'info');
        }

        log(`Building transaction to ${actualTo}...`);

        const network = await provider.getNetwork();
        const nonce = await provider.getTransactionCount(walletAddress);
        const feeData = await provider.getFeeData();

        let gasLimit;
        const gasLimitInput = document.getElementById('gasLimit').value;
        if (gasLimitInput) {
          gasLimit = BigInt(gasLimitInput);
        } else if (isL2Target) {
          // L2 target: proxy may not exist yet, so estimateGas would return 21k.
          // The builder will deploy the proxy + execute handleIncomingCall,
          // which needs significantly more gas.
          gasLimit = 500000n;
          log(`Using L2 target gas limit: ${gasLimit}`, 'info');
        } else {
          try {
            const estimated = await provider.estimateGas({
              from: walletAddress,
              to: actualTo,
              value: ethers.parseEther(value),
              data: data,
            });
            gasLimit = estimated * 120n / 100n;
          } catch {
            gasLimit = 100000n;
          }
        }

        const txRequest = {
          from: walletAddress,
          to: actualTo,
          value: '0x' + ethers.parseEther(value).toString(16),
          data: data,
          nonce: '0x' + nonce.toString(16),
          gas: '0x' + gasLimit.toString(16),
          maxFeePerGas: '0x' + (feeData.maxFeePerGas || ethers.parseUnits('10', 'gwei')).toString(16),
          maxPriorityFeePerGas: '0x' + (feeData.maxPriorityFeePerGas || ethers.parseUnits('1', 'gwei')).toString(16),
          chainId: '0x' + network.chainId.toString(16),
          type: '0x2',
        };

        if (isL2Target) {
          log(`Registering L1→L2 hint...`);
          try {
            await fetch(`${RPC_PROXY_URL}/register-hint`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ proxyAddress: actualTo, l2TargetAddress: toAddr }),
            });
          } catch (hintErr) {
            log(`Hint registration failed: ${hintErr.message}`, 'error');
          }
        }

        log(`Requesting signature...`);

        let signedTx;
        let usedDirectSend = false;

        try {
          signedTx = await window.ethereum.request({
            method: 'eth_signTransaction',
            params: [txRequest],
          });
          log(`Signed via eth_signTransaction`, 'success');
        } catch {
          log(`Using eth_sendTransaction...`, 'info');
          const txHash = await window.ethereum.request({
            method: 'eth_sendTransaction',
            params: [txRequest],
          });
          log(`Sent: ${txHash}`, 'success');
          const receipt = await provider.waitForTransaction(txHash);
          log(`Mined in block ${receipt.blockNumber}`, 'success');
          usedDirectSend = true;
          signedTx = txHash;
        }

        if (usedDirectSend) {
          showStatus('submitStatus', `Success! TX: ${signedTx}`, 'success');
          setTimeout(refreshStatus, 2000);
          return;
        }

        log(`Submitting to builder...`);
        const response = await fetch(`${builderUrl}/submit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ signedTx, hints, sourceChain: connectedChain })
        });

        if (!response.ok) {
          const error = await response.text();
          throw new Error(`Builder error: ${error}`);
        }

        const result = await response.json();
        log(`Builder accepted! L1 TX: ${result.l1TxHash}`, 'success');
        showStatus('submitStatus', `Success! TX: ${result.l1TxHash}`, 'success');

        setTimeout(refreshStatus, 2000);

      } catch (err) {
        log(`Error: ${err.message}`, 'error');
        showStatus('submitStatus', err.message, 'error');
      } finally {
        submitBtn.disabled = false;
      }
    });

    // ============ State History Refresh Button ============
    document.getElementById('refreshHistory').addEventListener('click', () => {
      refreshStateHistory();
    });

    // ============ Initialize ============
    log('Dashboard loaded.');
    updateUI();
    refreshStatus();
    refreshStateHistory();

    // Auto-refresh every 10 seconds
    statusRefreshInterval = setInterval(() => {
      refreshStatus();
      refreshStateHistory();
    }, 10000);
  </script>
</body>
</html>
